<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="v0.10.0介绍 nodev10.0版本来了，对于性能官方肯定是说性能大大提高了 http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/ 大致翻译如下：">
<meta name="keywords" content="node.js">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs-v0.10.0 初探">
<meta property="og:url" content="http://yoursite.com/2013/03/12/js-ajax/index.html">
<meta property="og:site_name" content="snoopyxdy的博客">
<meta property="og:description" content="v0.10.0介绍 nodev10.0版本来了，对于性能官方肯定是说性能大大提高了 http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/ 大致翻译如下：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-26T03:48:18.871Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodejs-v0.10.0 初探">
<meta name="twitter:description" content="v0.10.0介绍 nodev10.0版本来了，对于性能官方肯定是说性能大大提高了 http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/ 大致翻译如下：">






  <link rel="canonical" href="http://yoursite.com/2013/03/12/js-ajax/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>nodejs-v0.10.0 初探 | snoopyxdy的博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">snoopyxdy的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不要用执行上的勤奋来掩盖思考上的懒惰</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/03/12/js-ajax/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="snoopyxdy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="snoopyxdy的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nodejs-v0.10.0 初探
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-03-12 17:25:57" itemprop="dateCreated datePublished" datetime="2013-03-12T17:25:57+08:00">2013-03-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-26 11:48:18" itemprop="dateModified" datetime="2018-11-26T11:48:18+08:00">2018-11-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2013/03/12/js-ajax/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count gitment-comments-count" data-xid="/2013/03/12/js-ajax/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>v0.10.0介绍</p>
<p>nodev10.0版本来了，对于性能官方肯定是说性能大大提高了</p>
<p><a href="http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/" target="_blank" rel="noopener">http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/</a></p>
<p>大致翻译如下：</p>
<a id="more"></a>
<p>很高兴一个新的稳定版本的node发布了。<br>这个分支带来了很多显著的改进，主要是api的调整，让我们更加容易使用并且向后兼容。<br>在之前的帖子中，我们介绍了stream2的api调整了，如果你还没有阅读他，请尽快阅读他。（剩下的就是说之前stream的api不是很完善，现在他们下决心要让这个api更好）</p>
<p>更重要的是stream作为node的核心，改变之后接口变得更加易用了。所以强烈建议使用stream2的api，对于node 0.8，你可以安装 readable-stream 包来支持。 </p>
<p>domain模块从实验级别提高到了不稳定级别（尼玛还是坑爹），使用了domain模块，我们不再依赖于 process.on(‘uncaughtException’) 这样的错误控制了，如果你还没有使用domain来做错误处理，那你就要仔细检查哪些中间件和异步回调了（感觉有点威胁啊~）。</p>
<p>在0.8以及之前， process.nextTick() 会在当前事件循环结束时调用，这样通常是会在I/O开始前被调用的。所以很多项目都会使用process.nextTick()让它晚点做，而在I/O之前，看上去这样是正确的。事实上在大负载的I/O情况下，nextTick可能工作不正常，出现线程竞争情况。所以在v0.10.0版本 process.nextTick() 会在js代码执行完成后调用，而不是写入事件循环，可以说变同步了。应该尽量避免使用  process.nextTick() 来做递归，如果非要这么做请使用 setImmediate 来代替。</p>
<p>当事件循环闲置时，node会告诉V8开始做GC。事实上要找到正确的时间GC是非常困难的，当你选错时间GC将会耗费大量时间。在实践中，禁用IdleNotification会得到更好的效果。（他们现在依靠V8的GC了，因为他们觉得V8会很聪明的知道什么时候GC是最合适的，而不去手动的通知了）</p>
<p>再下面就是一些性能测试了，可以看出我们在响应大数据的字符串时，尽量使用buffer提高性能，v0.10.0在http方面要快于v0.8版本要快7%左右，读写文件性能也是提升显著。所以官方建议大家有条件的一定要升级到v0.10.0。</p>
<p>PS：当然现在还有使用古董级的0.6.x~</p>
<p>API改变：<br><a href="https://github.com/joyent/node/wiki/Api-changes-between-v0.8-and-v0.10" target="_blank" rel="noopener">https://github.com/joyent/node/wiki/Api-changes-between-v0.8-and-v0.10</a><br>大致意思是stream api的改变比较大，<br>1、增加了Readable, Writable, Duplex, and Transform的基类，我们可以直接从这些基类继承了<br>2、Readable streams 使用一个read方法，代替触发“data”的情况<br>3、增加一个”data”的监听器，或者调用“pause()” 和 “resume()” 会切换到旧stream模式<br>4、“data”的事件监听器永远不会错过第一个文件块，无论他们是否马上建立，pause 不再是咨询，而可以保证暂停<br>5、如果你不消耗数据，stream流永远是处于pause等待状态，而永远不会触发end事件<br>6、process.nextTick 会在当前事件结束调用，会在当前堆释放时执行，如果你打算递归的使用，请用setImmediate 代替<br>7、url.parse 将返回更多的信息如下：<br>// v0.8</p>
<blockquote>
<p>url.parse(‘<a href="http://foo&#39;" target="_blank" rel="noopener">http://foo&#39;</a>)<br>{ protocol: ‘http:’,<br>  slashes: true,<br>  host: ‘foo’,<br>  hostname: ‘foo’,<br>  href: ‘<a href="http://foo/&#39;" target="_blank" rel="noopener">http://foo/&#39;</a>,<br>  pathname: ‘/‘,<br>  path: ‘/‘ }</p>
</blockquote>
<p>// 0.10</p>
<blockquote>
<p>url.parse(‘<a href="http://foo&#39;" target="_blank" rel="noopener">http://foo&#39;</a>)<br>{ protocol: ‘http:’,<br>  slashes: true,<br>  auth: null,<br>  host: ‘foo’,<br>  port: null,<br>  hostname: ‘foo’,<br>  hash: null,<br>  search: null,<br>  query: null,<br>  pathname: ‘/‘,<br>  path: ‘/‘,<br>  href: ‘<a href="http://foo/&#39;" target="_blank" rel="noopener">http://foo/&#39;</a> }<br>8、domain模块对错误对象增加一个属性camelCase 代替snake_case<br>9、path.resolve 和 path.join 将会抛出异常，当传递的参数为空字符串时<br>10、dgram.Socket #bind() 会是一个异步方法，请在第二个参数增加回调函数<br>11、EventEmitter 基类的继承请使用新方法，以下方法将不会被支持：<br>function Child() {}<br>Child.prototype = new Parent(); // &lt;– NEVER EVER DO THIS!!<br>使用如下的代码代替上面的：（终于js有点像样点的继承了，蛋疼了多少年啊）<br>// Correct-Style Inheritance<br>function Child() {}<br>Child.prototype = Object.create(Parent.prototype, {<br>  constructor: {<br>    value: Child,<br>    enumerable: false,<br>    writable: true,<br>    configurable: true<br>  }<br>});<br>// “Gee that’s a lot of lines! I wish there was a helper method!”<br>// There is.  Do this:<br>util.inherits(Child, Parent);</p>
</blockquote>
<p>12、增加的一些api<br>12.1、stream增加 Readable, Writable, Duplex, and Transform 基类<br>12.2、crypto 的api 有stream接口的支持<br>12.3、process增加getgroups(), setgroups(), initgroups()<br>12.4、crypto增加getHashes() getCiphers()<br>12.5、http模块增加 response.headersSent 属性<br>12.6、增加‘removeListener’这个事件的触发，可以监听这个事件<br>12.6、增加setImmediate() 和 clearImmediate() 函数<br>12.7、字符串解码器增加   decoder.end() 函数</p>
<p>stream2：<br>最后我们来看一下stream2的一些api和新用法，首先我们要升级node到v0.10.0</p>
<h1 id="node-v"><a href="#node-v" class="headerlink" title="node -v"></a>node -v</h1><p>v0.10.0</p>
<p>stream是一个抽象类，它类继承自EventEmitter，例如http服务器就是一个stream，它是可读可写的，在早期的node版本中，stream类的接口是简单的，但是不够强大，可用性也不好。<br>1、不是当你调用read()函数，数据data将会马上接受，如果你想要做一些I/O来决定如何处理这些数据，你不得不建立一个buffer来存储那些数据。<br>2、pause()方法只是咨询，不能保证，可能当你调用pause()方法后，你还在接受data。</p>
<p>很多项目都无须调用data事件来监听，也不调用pause()和resume()方法。<br>我们看如下代码：<br>// WARNING!  BROKEN!<br>net.createServer(function(socket) {</p>
<p>  // we add an ‘end’ method, but never consume the data<br>  socket.on(‘end’, function() {<br>    // It will never get here.<br>    socket.end(‘I got your message (but didnt read it)\n’);<br>  });</p>
<p>}).listen(1337);<br>在v0.10.0版本之前，发送过来的数据将会丢失，因为我们没有做data事件的监听。在v0.10.0及以后，上面这段代码socket会一直处于暂停状态而接受数据</p>
<p>解决方法，代码如下：<br>// Workaround<br>net.createServer(function(socket) {</p>
<p>  socket.on(‘end’, function() {<br>    socket.end(‘I got your message (but didnt read it)\n’);<br>  });</p>
<p>  // start the flow of data, discarding it.<br>  socket.resume();</p>
<p>}).listen(1337);</p>
<p>创建一个只读stream类实例：<br>new stream.Readable([options])<br>options可配置<br>1、highWaterMark  {Number} ，这个数字表示read stream 缓冲区，默认16kb<br>2、encoding {String} 表示buffer的类型，默认为null，可以传入字符串的格式，比如utf-8<br>3、objectMode {Boolean} 表示是返回一个buffer对象还是值返回这个buffer对象的size n</p>
<p>readable._read(size)<br>这个方法不应该被直接调用，应该被内部的readable class 调用。所有readable的stream都必须提供一个_read的方法从数据源来获取数据。<br>size参数是咨询的，可能不是很正确，当使用tcp或者tls时会忽略这个参数。所以没有必要等设定的size的数据都到了，才去调用stream.push(chunk)方法</p>
<p>readable.push(chunk)<br>chunk {Buffer | null | String} 将块放入队列<br>return {Boolean}  如果为false则表示没有数据进行push<br>这个方法不是给readable消费者调用，而是给数据发送者调用，将数据push进队列里，push后，_read()方法就会从队列里读取数据了。<br>push方法明确的对readable队列内插入数据，当插入null时，则会发出数据发送完毕的信号<br>看一下简单的代码：<br>// source is an object with readStop() and readStart() methods,<br>// and an <code>ondata</code> member that gets called when it has data, and<br>// an <code>onend</code> member that gets called when the data is over.</p>
<p>var stream = new Readable(); //实例化</p>
<p>source.ondata = function(chunk) {<br>  // if push() returns false, then we need to stop reading from source<br>  if (!stream.push(chunk))<br>    source.readStop();<br>};</p>
<p>source.onend = function() {<br>  stream.push(null);<br>};</p>
<p>// _read will be called when the stream wants to pull more data in<br>// the advisory size argument is ignored in this case.<br>stream._read = function(n) {<br>  source.readStart();<br>};</p>
<p>readable.unshift(chunk)<br>chunk {Buffer | null | String} 将块从队列头部push<br>return {Boolean}  如果为false则表示没有数据进行unshift<br>看实例代码：<br>// A parser for a simple data protocol.<br>// The “header” is a JSON object, followed by 2 \n characters, and<br>// then a message body.<br>//<br>// Note: This can be done more simply as a Transform stream.  See below.</p>
<p>function SimpleProtocol(source, options) { //定义一个SimpleProtocol 类<br>  if (!(this instanceof SimpleProtocol))<br>    return new SimpleProtocol(options);</p>
<p>  Readable.call(this, options);//执行readable构造函数<br>  this._inBody = false; //_inbody表示是否开始接受body<br>  this._sawFirstCr = false; //表示是否看见第一个换行</p>
<p>  // source is a readable stream, such as a socket or file<br>  this._source = source; //将数据源赋值到this._source,source是一个readable stream</p>
<p>  var self = this;<br>  source.on(‘end’, function() { //当数据源 end 事件触发，则 SimpleProtocol 实例push一个null，表示没有数据push到队列中<br>    self.push(null);<br>  });</p>
<p>  // give it a kick whenever the source is readable<br>  // read(0) will not consume any bytes<br>  source.on(‘readable’, function() { //read(0) 表示不消费任何字节<br>    self.read(0);<br>  });</p>
<p>  this._rawHeader = []; //存放待格式化的头部的数组<br>  this.header = null;<br>}</p>
<p>SimpleProtocol.prototype = Object.create( //SimpleProtocol继承readable类<br>  Readable.prototype, { constructor: { value: SimpleProtocol }});</p>
<p>SimpleProtocol.prototype._read = function(n) {<br>  if (!this._inBody) { //如果还没接受body，表示接受head<br>    var chunk = this._source.read(); //从source中读取chunck</p>
<pre><code>// if the source doesn&apos;t have data, we don&apos;t have data yet.
//如果source还没有数据，那我们就push空字符串
if (chunk === null)
  return this.push(&apos;&apos;);

// check if the chunk has a \n\n 
var split = -1;
for (var i = 0; i &lt; chunk.length; i++) { //开始逐个解析chunk中的字符串，查看是否包含2个连续的/n
  if (chunk[i] === 10) { // &apos;\n&apos;  //如果发现是/n
    if (this._sawFirstCr) { //如果上一个也是 /n 则这边为true
      split = i; //找到了连续了/n 表示头部结束了，跳出循环，记录位置
      break;
    } else { //如果上一个字符不是 /n ，则把 _sawFirstCr 设为true
      this._sawFirstCr = true;
    }
  } else { //如果本字符不是 /n 则 _sawFirstCr 设置为false
    this._sawFirstCr = false;
  }
}

if (split === -1) { //如果没有找到2个/n则继续等待，push空字符串，将chunk暂时保存
  // still waiting for the \n\n
  // stash the chunk, and try again.
  this._rawHeader.push(chunk);
  this.push(&apos;&apos;);
} else {  //如果找到2个/n了，则表示以后就开始接受body
  this._inBody = true; //将inbody设置为true，表示今后开始接受body
  var h = chunk.slice(0, split); //将此次的chunk切分，头部放入待格式化数组
  this._rawHeader.push(h); 
  var header = Buffer.concat(this._rawHeader).toString(); //然后将待格式化数组中的内容组合
  try {
    this.header = JSON.parse(header); //转化js对象
  } catch (er) {
    this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
    return;
  }
  // now, because we got some extra data, unshift the rest
  // back into the read queue so that our consumer will see it.
  var b = chunk.slice(split); 
  this.unshift(b);//此时将chunk中取出的b也就是body部分，再塞回队列头部

  // and let them know that we are done parsing the header.
  this.emit(&apos;header&apos;, this.header);  //触发header事件，并且把this.header作为参数传递过去
}
</code></pre><p>  } else { //表示开始接受body<br>    // from there on, just provide the data to our consumer.<br>    // careful not to push(null), since that would indicate EOF.<br>    //从这里开始，表示对我们的消费者也就是api使用者提供数据了，注意不要push(null),因为null表示结束<br>    var chunk = this._source.read();<br>    if (chunk) this.push(chunk);<br>  }<br>};</p>
<p>// Usage:<br>var parser = new SimpleProtocol(source);<br>// Now parser is a readable stream that will emit ‘header’<br>// with the parsed header data.<br>//这样parser就可以解析source的数据了，当header解析完毕，就会触发 header 事件</p>
<p>readable.wrap(stream)<br>主要是用来向前兼容的，如果你使用了旧的node库，还使用data事件触发和pause()，则可以使用wrap来创建一个readable stream，这个stream是用旧的的数据源，代码如下：<br>var OldReader = require(‘./old-api-module.js’).OldReader;<br>var oreader = new OldReader;<br>var Readable = require(‘stream’).Readable;<br>var myReader = new Readable().wrap(oreader);</p>
<p>myReader.on(‘readable’, function() {<br>  myReader.read(); // etc.<br>});</p>
<p>Event: ‘readable’<br>当数据准备好被消费时，这个事件就会被触发，当这个事件触发，调用read()方法去消费数据</p>
<p>Event: ‘end’<br>当stream接受到eof关闭，则会触发此事件，指示没有数据会再发送，如果这个stream是可写的，则可能它还在被写入</p>
<p>Event: ‘error’<br>触发error事件</p>
<p>Event: ‘close’<br>当数据源关闭触发，并不是所有的数据源都会触发</p>
<p>readable.setEncoding(encoding)<br>设置data事件触发的参数是什么格式的，比如buffer或者utf-8</p>
<p>readable.read([size])<br>size {Number | null}  定义读取多少数据<br>Return: {Buffer | String | null} 返回buffer或者string<br>注意：这个方法是被stream消费者调用的<br>size的单位是bytes，如果不设置，则会返回内部buffer的整个内容。如果没有数据或者小于size的值，则null会返回，将来当返回更多了时候，会触发readable事件来让你消费数据<br>调用read(0)总是会返回null，并且会触发一次内部buffer的刷新，但是除此之外没有其他操作</p>
<p>readable.pipe(destination, [options])<br>destination {Writable Stream}    目标，一个可写入的stream<br>options {Object} Optional          设定参数<br>end {Boolean} Default=true       或者是一个布尔值表示是否关闭可写的stream，默认true的话会触发end事件，关闭stream<br>注意 process.stderr 和 process.stdout 除非进程退出，否则不会被关闭</p>
<p>readable.unpipe([destination])<br>destination {Writable Stream}  可选参数<br>撤销一个先前建立的pipe，如果参数destination 没有提供，则先前所有建立的pipe都被移除</p>
<p>readable.pause()<br>切换readable stream为旧模式，当data事件触发，则使用一个data事件监听，而不是通过read()方法消费buffer缓存的数据。<br>停止数据流，当stream处于paused状态时，没有data事件会被触发</p>
<p>readable.resume()<br>在执行pause()方法之后，回复接受发送来的数据流</p>
<p>Class: stream.Writable<br>一个可写的流，拥有如下的方法，成员和事件<br>注意：可写流是一个抽象类， _write(chunk, encoding, cb) 设计是用来扩展底层实现的</p>
<p>new stream.Writable([options])<br>options {Object}<br>highWaterMark {Number}   缓冲区，当写入开始后返回false<br>decodeStrings {Boolean}    是否将string改写为buffer写入，默认是<br>如果要扩展writable 类，确认需要正确调用它的构造函数</p>
<p>writable._write(chunk, encoding, callback)<br>chunk {Buffer | String}  写入的chunk一直是buffer，除非在实例化时显示声明 decodeStrings  为 false<br>encoding {String}    如果chunk是字符串，则设置他的编码，如果chunk是buffer则会忽略此属性，注意chunk一直是buffer，除非显示的将decodeStrings 设置为false<br>callback {Function}   此函数拥有一个可选的error参数，当处理完成提供的chunk会调用。</p>
<p>所有的可写流实现必须提供一个_write方法来将数据发送给底层实现。</p>
<p>writable.write(chunk, [encoding], [callback])<br>chunk {Buffer | String}   写入的数据<br>encoding {String} Optional.  如果写入的chunk是string，则encode默认为utf-8<br>callback {Function} Optional.  当chunk成功写入后调用<br>Returns {Boolean}  返回布尔值</p>
<p>将chunk写入stream，返回true表示数据已经写入底层，放回false表明buffer已经满了，数据将会在将来发送过去，drain事件会在buffer空了时候触发。什么时候write返回false，这取决于 highWaterMark  的设置</p>
<p>writable.end([chunk], [encoding], [callback])<br>chunk {Buffer | String} Optional final data to be written<br>encoding {String} Optional. If chunk is a string, then encoding defaults to ‘utf8’<br>callback {Function} Optional. Called when the final chunk is successfully written.<br>调用这个方法表示最后的data写入了stream</p>
<p>Event: ‘drain’<br>当stream的可写缓冲区为空时触发，当stream.write()返回false时监听它</p>
<p>#下面的比较简单不翻译了<br>Event: ‘close’<br>Emitted when the underlying resource (for example, the backing file descriptor) has been closed. Not all streams will emit this.</p>
<p>Event: ‘finish’<br>When end() is called and there are no more chunks to write, this event is emitted.</p>
<p>Event: ‘pipe’<br>source {Readable Stream}<br>Emitted when the stream is passed to a readable stream’s pipe method.</p>
<p>Event ‘unpipe’<br>source {Readable Stream}<br>Emitted when a previously established pipe() is removed using the source Readable stream’s unpipe() method.</p>
<p>Class: stream.Duplex<br>duplex stream是一个可读可写流，类似TCP socket链接</p>
<p>因为js没有多重继承，所以duplex类继承自readable类，然后寄生在writeable，因此他同时拥有_read()和_write()这2个方法，你可以扩展他们。</p>
<p>new stream.Duplex(options)<br>options {Object}  同上<br>allowHalfOpen {Boolean} Default=true. 如果设置为false，则stream会自动将readable stream关闭，当可写流关闭，反之亦然</p>
<p>Class: stream.Transform<br>transform流是一个duplex流，它对于input和output存在因果关系，比如zlibstream或者一个crypto。</p>
<p>对于传入的数据和传出的数据时不同大小的，不同的数据块大小和不同的到达时间。例如：一个hash 流仅会output一个chunk当input输入完毕。一个zlib流可能会将输入流处理为更大或更小</p>
<p>不用提供  _read()  和 _write() ，Transform 类必须提供 _transform() 方法，并且可能有一个可设定的提供_flush() 方法</p>
<p>new stream.Transform([options])<br>options {Object}  同上</p>
<p>transform._transform(chunk, encoding, callback)<br>chunk {Buffer | String}  写入的chunk一直是buffer，除非在实例化时显示声明 decodeStrings  为 false<br>encoding {String}如果chunk是字符串，则设置他的编码，如果chunk是buffer则会忽略此属性，注意chunk一直是buffer，除非显示的将decodeStrings 设置为false  此函数拥有一个可选的error参数，当处理完成提供的chunk会调用。</p>
<p>所有的Transform流实现必须提供一个_transform 方法来接受输入和输出</p>
<p>_transform 必须做任何此类特殊Transform 类的事情，处理字节的写入，然后将他们发送到可读部分的接口。做一些异步I/O，处理事情等等。<br>调用 transform.push(outputChunk) 0次或多次，用来生成从输入到输出chunk块，次数是根据你想要对这个chunk输出多少块。<br>仅会在当前chunk已经完全被消费时才会调用callback函数。注意，可能有些特殊的输入input块没有output结果。</p>
<p>transform._flush(callback)<br>callback {Function}  这个回调函数会有一个可选的error参数，当你执行完flushing任何其余的数据</p>
<p>在某些情况下，你的 transform 操作可能需要在流结束时，触发一个大一点的数据。比如zlib的压缩流会保存一些内部状态，所以它能达到最佳压缩状态，尽管到了最后，它还是需要一些数据，这样数据就会完整了。<br>在这情况，你需要执行 _flush 方法，它会被调用在非常后面，在所有数据都被消费掉，但是还没有出发end的信号之前。回调会在flush操作完成之后执行。</p>
<p>Example: SimpleProtocol parser<br>上面那个 simple protocol parser 可以被高级的 Transform stream class 更简单的实现出来。<br>在这个示例中，不用提供input作为参数，他将会通过pipe管道来解析，这将会更加通用的node 流方法。</p>
<p>function SimpleProtocol(options) {<br>  if (!(this instanceof SimpleProtocol))<br>    return new SimpleProtocol(options);</p>
<p>  Transform.call(this, options);<br>  this._inBody = false;<br>  this._sawFirstCr = false;<br>  this._rawHeader = [];<br>  this.header = null;<br>}</p>
<p>SimpleProtocol.prototype = Object.create(<br>  Transform.prototype, { constructor: { value: SimpleProtocol }});</p>
<p>SimpleProtocol.prototype._transform = function(chunk, encoding, done) {<br>  if (!this._inBody) {<br>    // check if the chunk has a \n\n<br>    var split = -1;<br>    for (var i = 0; i &lt; chunk.length; i++) {<br>      if (chunk[i] === 10) { // ‘\n’<br>        if (this._sawFirstCr) {<br>          split = i;<br>          break;<br>        } else {<br>          this._sawFirstCr = true;<br>        }<br>      } else {<br>        this._sawFirstCr = false;<br>      }<br>    }</p>
<pre><code>if (split === -1) {
  // still waiting for the \n\n
  // stash the chunk, and try again.
  this._rawHeader.push(chunk);
} else {
  this._inBody = true;
  var h = chunk.slice(0, split);
  this._rawHeader.push(h);
  var header = Buffer.concat(this._rawHeader).toString();
  try {
    this.header = JSON.parse(header);
  } catch (er) {
    this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
    return;
  }
  // and let them know that we are done parsing the header.
  this.emit(&apos;header&apos;, this.header);

  // now, because we got some extra data, emit this first.
  this.push(b);
}
</code></pre><p>  } else {<br>    // from there on, just provide the data to our consumer as-is.<br>    this.push(b);<br>  }<br>  done();<br>};</p>
<p>var parser = new SimpleProtocol();<br>source.pipe(parser) //坑爹就是这里改变了</p>
<p>// Now parser is a readable stream that will emit ‘header’<br>// with the parsed header data.</p>
<p>Class: stream.PassThrough<br>这是一个对transform的简单实现，他就是简单的将input转为output输出，它的目的是用来做示例和测试的，但是也有偶尔的情况它可以派上用场。</p>
<p>实际使用<br>stream2类介绍完毕了，我们看一下新的stream2类如何在实际使用，http发送请求，获取yahoo网站<br>var http = require(“http”)<br>var options = {<br>  hostname: ‘<a href="http://www.yahoo.com&#39;" target="_blank" rel="noopener">www.yahoo.com&#39;</a>,<br>  port: 80,<br>  path: ‘/‘,<br>  method: ‘GET’<br>};<br>var req = http.request(options, function(res) {<br>  //console.log(‘STATUS: ‘ + res.statusCode);<br>  //console.log(‘HEADERS: ‘ + JSON.stringify(res.headers));<br>  res.setEncoding(‘utf8’);<br>  res.on(‘readable’, function () {<br>      console.log(res.read())//这里就无须监听data事件然后拼字符串buffer之类了，直接监听可读事件，然后调用res.read()<br>  });<br>});<br>req.on(‘error’, function(e) {<br>  console.log(‘problem with request: ‘ + e.message);<br>});<br>// write data to request body<br>req.write(‘data\n’);<br>req.write(‘data\n’);<br>req.end();</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node-js/" rel="tag"># node.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/03/09/js-ajax/" rel="next" title="Google Protocol Buffer（1） - hellowrold">
                <i class="fa fa-chevron-left"></i> Google Protocol Buffer（1） - hellowrold
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2013/03/14/lua/" rel="prev" title="nginx_lua(3) - openapi项目有感">
                nginx_lua(3) - openapi项目有感 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">snoopyxdy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">284</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#node-v"><span class="nav-number">1.</span> <span class="nav-text">node -v</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">snoopyxdy</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="http://wzhfile.static.xytang88.com/gitmint.browser.js?v=3"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'DoubleSpout',
            repo: 'dsblog',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '202e5bcda8eacf79e44b6261326de2e79eff846e',
            
                client_id: '7d56dc5e01e83a1a44bb'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
