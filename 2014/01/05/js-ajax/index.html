<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="说来也惭愧，知道pomelo框架已经一年有余了，最近因为有开发IM的需求，但却是第一次部署安装pomelo框架，对不起网易开发团队的朋友~ pomelo的wiki上有一个分布式chat聊天室的例子，开发团队写的很仔细，详细对比了传统单进程聊天服务器的弊端，并给出pomelo框架分布式聊天服务器的优势，相关wiki地址如下：">
<meta name="keywords" content="node.js">
<meta property="og:type" content="article">
<meta property="og:title" content="pomelo分布式聊天服务器详解">
<meta property="og:url" content="http://yoursite.com/2014/01/05/js-ajax/index.html">
<meta property="og:site_name" content="snoopyxdy的博客">
<meta property="og:description" content="说来也惭愧，知道pomelo框架已经一年有余了，最近因为有开发IM的需求，但却是第一次部署安装pomelo框架，对不起网易开发团队的朋友~ pomelo的wiki上有一个分布式chat聊天室的例子，开发团队写的很仔细，详细对比了传统单进程聊天服务器的弊端，并给出pomelo框架分布式聊天服务器的优势，相关wiki地址如下：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-26T03:48:18.873Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pomelo分布式聊天服务器详解">
<meta name="twitter:description" content="说来也惭愧，知道pomelo框架已经一年有余了，最近因为有开发IM的需求，但却是第一次部署安装pomelo框架，对不起网易开发团队的朋友~ pomelo的wiki上有一个分布式chat聊天室的例子，开发团队写的很仔细，详细对比了传统单进程聊天服务器的弊端，并给出pomelo框架分布式聊天服务器的优势，相关wiki地址如下：">






  <link rel="canonical" href="http://yoursite.com/2014/01/05/js-ajax/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>pomelo分布式聊天服务器详解 | snoopyxdy的博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">snoopyxdy的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不要用执行上的勤奋来掩盖思考上的懒惰</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/01/05/js-ajax/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="snoopyxdy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="snoopyxdy的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">pomelo分布式聊天服务器详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2014-01-05 11:43:49" itemprop="dateCreated datePublished" datetime="2014-01-05T11:43:49+08:00">2014-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-26 11:48:18" itemprop="dateModified" datetime="2018-11-26T11:48:18+08:00">2018-11-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/01/05/js-ajax/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count gitment-comments-count" data-xid="/2014/01/05/js-ajax/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>说来也惭愧，知道pomelo框架已经一年有余了，最近因为有开发IM的需求，但却是第一次部署安装pomelo框架，对不起网易开发团队的朋友~</p>
<p>pomelo的wiki上有一个分布式chat聊天室的例子，开发团队写的很仔细，详细对比了传统单进程聊天服务器的弊端，并给出pomelo框架分布式聊天服务器的优势，相关wiki地址如下：</p>
<a id="more"></a>
<p>tutorial1 分布式聊天<br>部署这个聊天demo非常简单，去github上下载这个聊天室的源代码，然后根据wiki里的程序安装依赖，并且分别启动pomelo的game server和web server。<br>代码下载地址：<br><a href="https://github.com/NetEase/chatofpomelo" target="_blank" rel="noopener">https://github.com/NetEase/chatofpomelo</a></p>
<p>我刚运行这个聊天室程序的时候确实有点迷糊，看了wiki上的架构图又是web server，又是gate server，还有多个connecter，还有chat server等等，在config .json里可以进行相关的一些配置：<br>“development”:{<br>        “connector”:[<br>             {“id”:”connector-server-1”, “host”:”127.0.0.1”, “port”:4050, “clientPort”: 3050, “frontend”: true},<br>             {“id”:”connector-server-2”, “host”:”127.0.0.1”, “port”:4051, “clientPort”: 3051, “frontend”: true},<br>             {“id”:”connector-server-3”, “host”:”127.0.0.1”, “port”:4052, “clientPort”: 3052, “frontend”: true}<br>         ],<br>        “chat”:[<br>             {“id”:”chat-server-1”, “host”:”127.0.0.1”, “port”:6050},<br>             {“id”:”chat-server-2”, “host”:”127.0.0.1”, “port”:6051},<br>             {“id”:”chat-server-3”, “host”:”127.0.0.1”, “port”:6052}<br>        ],<br>        “gate”:[<br>           {“id”: “gate-server-1”, “host”: “127.0.0.1”, “clientPort”: 3014, “frontend”: true}<br>        ]<br>    },<br>其中frontend表示此服务器可以被用户请求到，clientPort表示此服务器对外的端口号，port表示此服务器对内部的rpc调用端口号。</p>
<p>启动好服务器之后，我们在浏览器地址栏中输入:<a href="http://127.0.0.1;3001/index.html就可以正常登录进行聊天了。从前端入手，我们先简单看一下前端页面的js代码，在web-server的public文件夹中存放了前端用到的html和js代码。" target="_blank" rel="noopener">http://127.0.0.1;3001/index.html就可以正常登录进行聊天了。从前端入手，我们先简单看一下前端页面的js代码，在web-server的public文件夹中存放了前端用到的html和js代码。</a><br>client.js就是整个聊天室用到的前端js代码，它的结构如下：<br>1、定义了很多用到的变量<br>2、定义了用来判断输入合法性的util对象<br>3、定义很多操作dom元素的function函数<br>4、定义queryEntry方法，这个方法比较重要，下面单独说明<br>5、定义很多事件，用来接收pomelo服务器响应的东西<br>6、对login按钮进行绑定click事件<br>7、对发送消息entry按钮绑定click事件<br>我们单独看下queryEntry方法，代码如下：<br>// query connector<br>function queryEntry(uid, callback) {<br>    var route = ‘gate.gateHandler.queryEntry’;<br>    pomelo.init({<br>        host: window.location.hostname,<br>        port: 3014,<br>        log: true<br>    }, function() {<br>        pomelo.request(route, {<br>            uid: uid<br>        }, function(data) {<br>            pomelo.disconnect();<br>            if(data.code === 500) {<br>                showError(LOGIN_ERROR);<br>                return;<br>            }<br>            callback(data.host, data.port);<br>        });<br>    });<br>};<br>其中我们看到pomelo.init方法，传入了host，port和log的参数，同时在回调函数里面使用pomelo.request方法将uid发送出去，在回调函数里断开连接，最后执行callback，将返回的data数据的host和port传入callback。</p>
<p>反正我第一次看这段代码是一头雾水，这个queryEntry函数是在用户点击登录之后执行的，我们打开public/js/lib/pomeloclient.js文件，找到init函数，代码如下：<br>pomelo.init = function(params, cb){<br>    pomelo.params = params;<br>    params.debug = true;<br>    var host = params.host;<br>    var port = params.port;</p>
<pre><code>var url = &apos;ws://&apos; + host;
if(port) {
  url +=  &apos;:&apos; + port;
}

socket = io.connect(url, {&apos;force new connection&apos;: true, reconnect: false});

socket.on(&apos;connect&apos;, function(){
  console.log(&apos;[pomeloclient.init] websocket connected!&apos;);
  if (cb) {
    cb(socket);
  }
});

socket.on(&apos;reconnect&apos;, function() {
  console.log(&apos;reconnect&apos;);
});

socket.on(&apos;message&apos;, function(data){
  if(typeof data === &apos;string&apos;) {
    data = JSON.parse(data);
  }
  if(data instanceof Array) {
    processMessageBatch(pomelo, data);
  } else {
    processMessage(pomelo, data);
  }
});

socket.on(&apos;error&apos;, function(err) {
  console.log(err);
});

socket.on(&apos;disconnect&apos;, function(reason) {
  pomelo.emit(&apos;disconnect&apos;, reason);
});
</code></pre><p>  };<br>其实上述代码就是利用socket.io于远程服务器建立连接，并且把socket对象传入回调函数。另外pomelo.request方法就是向这个socket发送数据，注意了整个pomelo对象是一个单例，所以我们在使用pomelo对象时同时只能连接一个服务器，所以代码中在连接gate服务器之后，获得connector服务器的主机名和端口就需要使用pomelo.disconnect();方法关闭这个连接，从而重新init连接被分配的connector服务器。<br>我们重点看下，这个route变量：<br>var route = ‘gate.gateHandler.queryEntry’;<br>这个地址就代表着gate服务器的方法地址，其中gateHandler表示文件名，queryEntry表示exports对外的方法名，通过前端的如下代码：<br>pomelo.request(route, {<br>            uid: uid<br>        },function(){..<br>我们就把uid发送到了gate服务器中的handler文件夹中，gateHandler.js这个文件里的queryEntry方法中了。在queryEntry方法中，其实什么事情都没有去做，只不过将用户uid根据哈希算法分配到一台connector服务器，gate并不会去做路由转发，而是直接返回给客户端connector的host和port，所以我们就看到了上述代码中前端关闭与gate服务器的连接，将收到的信息host和port传给callback函数了。<br>通过上述这些代码，我们基本了解到web服务器主要就是用来展现静态资源的，把他换成nginx或者apache都可以。而gate服务器也是独立与系统的，它的作用也不过是根据用户名来哈希计算分配给这个客户端的connector地址。</p>
<p>1、用户登录登出过程：<br>接下来我们看下，用户第一次进入页面，点击登录按钮发生了什么？代码如下：<br>queryEntry(username, function(host, port) {<br>            pomelo.init({<br>                host: host,<br>                port: port,<br>                log: true<br>            }, function() {<br>                var route = “connector.entryHandler.enter”;<br>                pomelo.request(route, {<br>                    username: username,<br>                    rid: rid<br>                }, function(data) {<br>                    if(data.error) {<br>                        showError(DUPLICATE_ERROR);<br>                        return;<br>                    }<br>                    setName();<br>                    setRoom();<br>                    showChat();<br>                    initUserList(data);<br>                });<br>            });<br>        });<br>queryEntry函数我们之前已经分析过了，回调函数接收的host和port值就是gate服务器分配的connector地址，我们使用同样的pomelo.init方法连接上connector服务器，然后调用远程地址”connector.entryHandler.enter”，将rid和username传给这个方法，当远程执行完毕之后，让此用户进入聊天室。这里我们打开connector文件夹下的entryHandler.js，查看enter方法：<br>handler.enter = function(msg, session, next) {<br>    var self = this;<br>    var rid = msg.rid;<br>    var uid = msg.username + ‘*’ + rid<br>    var sessionService = self.app.get(‘sessionService’);</p>
<pre><code>//duplicate log in
if( !! sessionService.getByUid(uid)) {
    next(null, {
        code: 500,
        error: true
    });
    return;
}

session.bind(uid);
session.set(&apos;rid&apos;, rid);
session.push(&apos;rid&apos;, function(err) {
    if(err) {
        console.error(&apos;set rid for session service failed! error is : %j&apos;, err.stack);
    }
});
session.on(&apos;closed&apos;, onUserLeave.bind(null, self.app));

//put user into channel
self.app.rpc.chat.chatRemote.add(session, uid, self.app.get(&apos;serverId&apos;), rid, true, function(users){
    next(null, {
        users:users
    });
});
</code></pre><p>};<br>这里用到的pomelo的api比较多，我们逐一解释，<br>首先我们先获取session服务<br>var sessionService = self.app.get(‘sessionService’);<br>然后通过下面的代码，判断这个用户是否已经存在了，如果已经存在那么就要返回error错误<br>if( !! sessionService.getByUid(uid)) {<br>        next(null, {<br>            code: 500,<br>            error: true<br>        });<br>        return;<br>    }<br>下面的代码是绑定用户uid到session中，并且将这个uid更新房间rid的session，然后利用push方法下发同步session，当session触发关闭事件后，就执行onUserLeave方法，并且绑定它的第一个参数是app<br>session.bind(uid);<br>session.set(‘rid’, rid);<br>session.push(‘rid’, function(err) {<br>        if(err) {<br>            console.error(‘set rid for session service failed! error is : %j’, err.stack);<br>        }<br>});<br>session.on(‘closed’, onUserLeave.bind(null, self.app));<br>这天通过app的rpc远程调用chatRemote.js的add方法，将一些参数传入，等待远程返回users对象，然后将users返回给客户端。<br>self.app.rpc.chat.chatRemote.add(session, uid, self.app.get(‘serverId’), rid, true, function(users){<br>        next(null, {<br>            users:users<br>        });<br>    });<br>最后是用户离开的函数，远程调用kick方法，将用户剔除。<br>var onUserLeave = function(app, session) {<br>    if(!session || !session.uid) {<br>        return;<br>    }<br>    app.rpc.chat.chatRemote.kick(session, session.uid, app.get(‘serverId’), session.get(‘rid’), null);<br>};<br>connector服务器的代码分析完了，主要作用就是将session绑定用户id，同时同步和下发session到chatserver中去，让chatserver在处理聊天的时候可以获取到用户身份。<br>接下来打开chat/remote/chatRemote.js文件，看下add和kick方法是怎么定义的。<br>先定义一个ChatRemote类，通过app.get获取’channelService’服务，这个上面的sessionService一样，拿到channelService对象之后，我们调用this.channelService.getChannel(channel_name,flag)，获取一个指定频道，通过查看pomelo的api文档我们可知，第二个参数flag如果为true，如果没查找到这个channel，那么就会去创建这个channel。<br>然后通过channel.pushMessage(param);方法向这个频道的所用客户端广播，这将触发client.js的onAdd事件，同时将用户名作为参数传入。<br>channel.add(uid, sid);这里将新登录的用户uid和connector_server_id添加到此频道中去。然后通过将this.get方法的返回值作为参数，传给回调函数函数。<br>var ChatRemote = function(app) {<br>    this.app = app;<br>    this.channelService = app.get(‘channelService’);<br>};<br>ChatRemote.prototype.add = function(uid, sid, name, flag, cb) {<br>    var channel = this.channelService.getChannel(name, flag);<br>    var username = uid.split(‘*’)[0];<br>    var param = {<br>        route: ‘onAdd’,<br>        user: username<br>    };<br>    channel.pushMessage(param);</p>
<pre><code>if( !! channel) {
    channel.add(uid, sid);
}

cb(this.get(name, flag));
</code></pre><p>};<br>我们看一下this.get函数做了什么事情，他的功能就是获取这个频道下面所有用户的uid数组<br>ChatRemote.prototype.get = function(name, flag) {<br>    var users = [];<br>    var channel = this.channelService.getChannel(name, flag);<br>    if( !! channel) {<br>        users = channel.getMembers();<br>    }<br>    for(var i = 0; i &lt; users.length; i++) {<br>        users[i] = users[i].split(‘<em>‘)[0];<br>    }<br>    return users;<br>};<br>我们通过connector的next函数，将这个用户数组传递给前端的回调函数执行，这样就将用户uid的列表正常返回给前端的client.js了。<br>另外一个kick的方法比较简单，主要就是将用户id从channel中剔除，然后触发用户的onLeave事件，告知这个channel中的用户此uid已经离开了。<br>ChatRemote.prototype.kick = function(uid, sid, name, cb) {<br>    var channel = this.channelService.getChannel(name, false);<br>    // leave channel<br>    if( !! channel) {<br>        channel.leave(uid, sid);<br>    }<br>    var username = uid.split(‘</em>‘)[0];<br>    var param = {<br>        route: ‘onLeave’,<br>        user: username<br>    };<br>    channel.pushMessage(param);<br>    cb();<br>};<br>至此，我们对用户进入聊天室和登出聊天室的功能已经有所了解了，下面我们要分析一下用户发送消息的广播和单播功能的实现。</p>
<p>2、消息广播和单播实现<br>我们还是打开public/client.js文件，找到用户发送消息的代码，如下：<br>代码中先定义了chat.chatHandler.send，这将直接使前端通过rpc调用chatHandler.js中的send方法。代码中还加入了一些合法性验证和去除空格的东西，核心代码是pomelo.request这段，前端将rid（频道名），content（消息内容），from（发送方用户id），target（接收方）作为参数传入，当服务器端处理完毕执行回调之后，我们通过addMessage函数将信息打印到网页上，其实后面那段$(“#chatHistory”).show();完全可以放在addMessage这个方法里面去，因为它本来就是addMessage的一个过程。<br>//deal with chat mode.<br>    $(“#entry”).keypress(function(e) {<br>        var route = “chat.chatHandler.send”;<br>        var target = $(“#usersList”).val();<br>        if(e.keyCode != 13 /<em> Return </em>/ ) return;<br>        var msg = $(“#entry”).attr(“value”).replace(“\n”, “”);<br>        if(!util.isBlank(msg)) {<br>            pomelo.request(route, {<br>                rid: rid,<br>                content: msg,<br>                from: username,<br>                target: target<br>            }, function(data) {<br>                $(“#entry”).attr(“value”, “”); // clear the entry field.<br>                if(target != ‘<em>‘ &amp;&amp; target != username) {<br>                    addMessage(username, target, msg);<br>                    $(“#chatHistory”).show();<br>                }<br>            });<br>        }<br>    });<br>前端代码不处理任何逻辑，我们看下被远程rpc调用的chatHandler.js中的send方法是如何处理聊天消息的。<br>先通过session获得当前发送消息的用户的信息，然后调用channelService服务，获取频道对象，判断如果target是</em>，那就代表频道广播，直接channel.pushMessage将消息广播，触发前端client.js的onChat方法。<br>如果target是指定的uid，表示单播，我们先拼接目标用户id，然后根据我们之前保存的frontend的serverid拿到sid，最后我们通过pushMessageByUids将消息给指定的用户单播推送出去，注意这里不能使用channel对象而是使用channelService。<br>handler.send = function(msg, session, next) {<br>    var rid = session.get(‘rid’);<br>    var username = session.uid.split(‘*’)[0];<br>    var channelService = this.app.get(‘channelService’);<br>    var param = {<br>        route: ‘onChat’,<br>        msg: msg.content,<br>        from: username,<br>        target: msg.target<br>    };<br>    channel = channelService.getChannel(rid, false);</p>
<pre><code>//the target is all users
if(msg.target == &apos;*&apos;) {
    channel.pushMessage(param);
}
//the target is specific user
else {
    var tuid = msg.target + &apos;*&apos; + rid;
    var tsid = channel.getMember(tuid)[&apos;sid&apos;];
    channelService.pushMessageByUids(param, [{
        uid: tuid,
        sid: tsid
    }]);
}
next(null, {
    route: msg.route
});
</code></pre><p>};<br>我们通过前端监听的onChat事件，将受到的消息放置在网页中，tip表示消息提醒功能。<br>pomelo.on(‘onChat’, function(data) {<br>        addMessage(data.from, data.target, data.msg);<br>        $(“#chatHistory”).show();<br>        if(data.from !== username)<br>            tip(‘message’, data.from);<br>    });<br>这样我们整个的聊天室群聊和单聊功能都已经开发完毕了，不过在看这些源码过程中还是碰到一些疑问的，可能需要去翻pomelo源码才能解决，总体感觉pomelo框架的文档不够详细，上手教程也不够详细，很多api不知道怎么用法，估计真正投入生产还是要把pomelo框架的源代码翻个遍才能得心应手的使用。<br>看完聊天室的代码，给我几个有疑惑的地方，等接下来深入pomelo框架之后，应该会有所解答：<br>1、用户的session和channel信息的保存，默认应该是保存在内存中的，如何把它保存到数据库中<br>2、session和channel的同步效率如何，目前还没测试过<br>3、对于connector或者chatserver的容灾问题，demo中也没考虑<br>4、gateserver理论上是可以支持分布式扩展的吧<br>5、如果connector和chat还有gate不在一台服务器上的话怎么处理？如何分别启动这些服务器和同步下发config？</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node-js/" rel="tag"># node.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/11/25/js-ajax/" rel="next" title="Node.js http 管道拒绝服务漏洞">
                <i class="fa fa-chevron-left"></i> Node.js http 管道拒绝服务漏洞
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/01/15/js-ajax/" rel="prev" title="如何更安全的用Node.js开发web应用">
                如何更安全的用Node.js开发web应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">snoopyxdy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">289</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">snoopyxdy</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="http://wzhfile.static.xytang88.com/gitmint.browser.js?v=3"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'DoubleSpout',
            repo: 'dsblog',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '202e5bcda8eacf79e44b6261326de2e79eff846e',
            
                client_id: '7d56dc5e01e83a1a44bb'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
